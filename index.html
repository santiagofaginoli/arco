<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Presentación: Procesamiento Multinúcleo e Hilos</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* Configuración de color principal: Azul Oscuro para un tono profesional */
        :root {
            --color-primary: #1e3a8a; /* Blue-800 */
            --color-secondary: #3b82f6; /* Blue-500 */
            --color-text-dark: #1f2937; /* Gray-800 */
        }

        body {
            font-family: 'Inter', sans-serif;
            /* Fondo con gradiente sutil para mayor profundidad */
            background: linear-gradient(135deg, #e0f2fe 0%, #f0f9ff 100%); 
            color: var(--color-text-dark);
        }

        /* Estilos de título principal */
        h1 {
            color: var(--color-primary);
            border-bottom: 4px solid var(--color-secondary);
            display: inline-block;
            padding-bottom: 0.5rem;
        }

        /* Estilos para títulos de sección */
        h2 {
            color: var(--color-primary);
            border-left: 5px solid var(--color-secondary);
            padding-left: 0.75rem;
        }

        /* Estilos de la tabla */
        .styled-table thead {
            background-color: var(--color-primary);
            color: white;
        }

        /* Estilos para ocultar los botones de control al imprimir */
        @media print {
            .no-print {
                display: none;
            }
            .document-container {
                box-shadow: none !important;
                border: none !important;
                margin: 0 !important;
                padding: 0 !important;
                width: 100% !important;
                background-color: white !important; /* Asegurar fondo blanco para impresión */
            }
        }
    </style>
</head>
<body class="flex flex-col items-center p-4 sm:p-8 min-h-screen">

    <main class="document-container w-full max-w-6xl bg-white rounded-3xl shadow-2xl p-6 md:p-12 lg:p-16 transition-shadow duration-300 hover:shadow-3xl">

        <header class="text-center mb-12">
            <h1 class="text-3xl sm:text-4xl lg:text-5xl font-extrabold mb-2 mx-auto">
                Procesamiento Multinúcleo e Hilos
            </h1>
            <p class="text-lg text-gray-500 mt-2 font-light">Arquitectura de Sistemas, Concurrencia y Sincronización Avanzada</p>
        </header>

        <section class="mb-14 p-6 bg-gray-50 rounded-xl">
            <h2 class="text-2xl sm:text-3xl font-bold mb-4">1. La Evolución de la Computación: Del Uninúcleo al Paralelismo</h2>
            <p class="text-base sm:text-lg leading-relaxed text-gray-700">Históricamente, el aumento de la velocidad de las computadoras se lograba incrementando la <strong>frecuencia (GHz)</strong>. Sin embargo, este camino se encontró con el muro de la energía: aumentar la frecuencia generaba una cantidad de calor (potencia) insostenible. Este fenómeno marcó el fin de la <strong>Ley de Moore</strong> en términos de aumento de velocidad de reloj.</p>
            <p class="text-base sm:text-lg leading-relaxed mt-4 p-4 border-l-4 border-blue-500 bg-blue-50">La solución fue el <strong class="text-blue-700 font-extrabold">procesamiento multinúcleo</strong>: pasar de una ejecución serial rápida a una <strong class="text-blue-700 font-extrabold">ejecución paralela</strong> simultánea. Esto no solo distribuye la carga de trabajo, sino que permite que la velocidad de procesamiento crezca linealmente con el número de núcleos, respetando las limitaciones físicas de temperatura y consumo de energía. El <strong class="font-extrabold">IBM Power 4 (2000)</strong> formalizó esta transición.</p>
            <p class="text-base sm:text-lg leading-relaxed mt-4 text-gray-700">⚠️ <strong>El Límite de la Ley de Amdahl:</strong> Este principio establece que la ganancia de velocidad (speedup) obtenida al paralelizar un programa está limitada por la fracción del código que debe ejecutarse de forma serial. Por más núcleos que se agreguen, el rendimiento nunca superará la velocidad de esa parte serial.</p>
        </section>

        <hr class="my-12 border-blue-200">

        <section class="mb-14">
            <h2 class="text-2xl sm:text-3xl font-bold mb-6">2. Definiciones Clave: Núcleos, Hilos y Procesos</h2>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                
                <div class="p-6 bg-white border border-gray-200 rounded-xl shadow-lg">
                    <h3 class="text-xl font-bold mb-4 text-blue-600 border-b pb-2">⚙️ Unidades de Hardware y Abstracción</h3>
                    <ul class="list-disc list-inside text-base sm:text-lg leading-relaxed space-y-3">
                        <li><strong class="font-bold">Núcleo Físico:</strong> Unidad de procesamiento con su propia<strong class="font-bold">unidad de control y unidades aritmético-lógicas (ALU)</strong>. Es el verdadero motor de ejecución independiente.</li>
                        <li><strong class="font-bold">Hyper-Threading / SMT:</strong> Permite que un solo núcleo físico gestione el estado (registros, caché) de dos hilos simultáneamente. Cuando un hilo se detiene para esperar datos (latencia de memoria), el núcleo salta inmediatamente al otro hilo. Esto resulta en <strong class="text-indigo-600">dos núcleos lógicos</strong> por núcleo físico.</li>
                    </ul>
                </div>
                
                <div class="p-6 bg-white border border-gray-200 rounded-xl shadow-lg">
                    <h3 class="text-xl font-bold mb-4 text-blue-600 border-b pb-2">💾 Unidades de Software (Contextos de Ejecución)</h3>
                    <ul class="list-disc list-inside text-base sm:text-lg leading-relaxed space-y-3">
                        <li><strong class="font-bold">Proceso:</strong> Es el <strong class="font-bold">contenedor de recursos</strong> completo. Incluye un espacio de direcciones de memoria virtual dedicado y privado, archivos abiertos y estructuras de datos del kernel. Crearlos es <strong class="text-red-500">lento</strong> (coste de crear la estructura de memoria).</li>
                        <li><strong class="font-bold">Hilo (o Thread):</strong> Es la <strong class="font-bold">secuencia de ejecución</strong> dentro de un proceso. Los hilos dentro del mismo proceso <strong class="font-extrabold text-green-600">comparten el mismo espacio de direcciones y recursos</strong> (heap, código, datos), pero cada uno tiene su propia pila y registros. Crearlos es <strong class="text-green-600">rápido</strong>.</li>
                    </ul>
                </div>
            </div>
        </section>

        <hr class="my-12 border-blue-200">

        <section class="mb-14">
            <h2 class="text-2xl sm:text-3xl font-bold mb-6">3. Concurrencia vs. Paralelismo: Conceptos Esenciales</h2>
            <p class="text-base sm:text-lg leading-relaxed mb-6 text-gray-700">Esta es la distinción más crítica para el diseño de sistemas. El paralelismo es una característica del hardware; la concurrencia es un concepto de diseño que optimiza la gestión de tareas.</p>
            
            <div class="overflow-x-auto rounded-xl shadow-xl">
                <table class="w-full text-base sm:text-lg text-left styled-table">
                    <thead class="text-xs uppercase lg:text-sm">
                        <tr>
                            <th scope="col" class="px-4 py-3 sm:px-6">Característica</th>
                            <th scope="col" class="px-4 py-3 sm:px-6">Concurrencia (Gestión y Control)</th>
                            <th scope="col" class="px-4 py-3 sm:px-6">Paralelismo (Ejecución y Desempeño)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="bg-white border-b hover:bg-gray-50">
                            <td class="px-4 py-4 sm:px-6 font-semibold text-gray-900">Definición</td>
                            <td class="px-4 py-4 sm:px-6">Capacidad de gestionar <strong class="font-bold">múltiples tareas a lo largo de un período</strong>, mediante cambio de contexto.</td>
                            <td class="px-4 py-4 sm:px-6">Capacidad de ejecutar <strong class="font-bold">múltiples tareas exactamente al mismo instante</strong> en diferentes unidades.</td>
                        </tr>
                        <tr class="bg-white border-b hover:bg-gray-50">
                            <td class="px-4 py-4 sm:px-6 font-semibold text-gray-900">Requisito Mínimo</td>
                            <td class="px-4 py-4 sm:px-6">Solo requiere <strong class="font-bold">un núcleo</strong> (uniprocesador).</td>
                            <td class="px-4 py-4 sm:px-6">Requiere <strong class="font-bold">múltiples núcleos</strong> (multinúcleo).</td>
                        </tr>
                        <tr class="bg-white hover:bg-gray-50">
                            <td class="px-4 py-4 sm:px-6 font-semibold text-gray-900">Impacto</td>
                            <td class="px-4 py-4 sm:px-6">Mejora el <strong class="font-bold">uso del sistema</strong> y la capacidad de respuesta.</td>
                            <td class="px-4 py-4 sm:px-6">Mejora el <strong class="font-bold">rendimiento total</strong> y reduce el tiempo de finalización.</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <hr class="my-12 border-blue-200">

        <section class="mb-14 p-6 border border-dashed border-indigo-300 rounded-xl">
            <h2 class="text-2xl sm:text-3xl font-bold mb-6">4. Modelos de Hilos en Sistemas Operativos: El Mapeo Lógico</h2>
            <p class="text-base sm:text-lg leading-relaxed mb-6 text-gray-700">El modelo de hilos determina qué tan bien un programa puede explotar el paralelismo del hardware, en función de cómo el <strong class="font-bold">sistema operativo (kernel)</strong> ve y gestiona los hilos creados por el programador (hilos de usuario).</p>
            
            <ul class="list-disc list-inside text-base sm:text-lg leading-relaxed space-y-4 marker:text-indigo-600">
                <li class="pl-4"><strong class="font-bold">Modelo Muchos a Uno (ULT):</strong> Varios hilos de usuario se mapean a un único hilo del kernel. 
                    <p class="text-sm text-gray-600 mt-1"><strong>Ventaja:</strong> Gestión extremadamente <strong>rápida</strong> ya que no hay llamadas al kernel. <strong>Desventaja:</strong> El <strong>bloqueo</strong> de un solo hilo por una I/O detiene todo el proceso. No se logra verdadero paralelismo en multicore.</p>
                </li>
                <li class="pl-4"><strong class="font-bold">Modelo Uno a Uno (KLT):</strong> Cada hilo de usuario tiene un hilo de kernel dedicado. (Usado por Linux, Windows).
                    <p class="text-sm text-gray-600 mt-1"><strong>Ventaja:</strong> Permite el <strong>paralelismo real</strong> en sistemas multinúcleo y el bloqueo de un hilo no afecta a los demás. <strong>Desventaja:</strong> Crear hilos es más <strong>lento</strong> porque implica una llamada al kernel y más sobrecarga de gestión para el SO.</p>
                </li>
                <li class="pl-4"><strong class="font-bold">Modelos Híbridos (Muchos a Muchos):</strong> Permite un número flexible de hilos de usuario que se mapean a un número menor o igual de hilos del kernel.
                    <p class="text-sm text-gray-600 mt-1"><strong>Ventaja:</strong> Intenta combinar la <strong>eficiencia</strong> de la gestión a nivel de usuario con la capacidad de <strong>paralelismo</strong> proporcionada por el kernel. <strong>Desventaja:</strong> Es el modelo más <strong>complejo</strong> de implementar y gestionar.</p>
                </li>
            </ul>
        </section>

        <hr class="my-12 border-blue-200">

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-10">
            
            <section class="p-6 bg-green-50 rounded-xl shadow-lg border border-green-200">
                <h2 class="text-2xl font-bold mb-4 text-green-700 border-l-4 border-green-500 pl-3">5. Ventajas y Métricas de Eficiencia del Multihilo</h2>
                <p class="text-base sm:text-lg leading-relaxed mb-4 text-gray-700">La adopción del multihilo se justifica por métricas de rendimiento y eficiencia, a pesar de los riesgos de sincronización.</p>
                
                <ul class="list-disc list-inside text-base sm:text-lg leading-relaxed space-y-3 marker:text-green-600">
                    <li class="pl-4"><strong class="font-bold">📈 Mejora de Rendimiento (Speedup):</strong> La principal razón. Se busca reducir el tiempo total de ejecución (Wall Clock Time) dividiendo la carga computacional en partes paralelas.</li>
                    <li class="pl-4"><strong class="font-bold">🛠️ Economía en Creación:</strong> Crear un nuevo proceso puede consumir cientos de miles de ciclos de CPU. Crear un hilo solo requiere asignar una pila y una estructura de control (unos pocos miles de ciclos), lo que es mucho más económico.</li>
                    <li class="pl-4"><strong class="font-bold">♻️ Bajo Coste de Conmutación:</strong> El <strong>cambio de contexto</strong> entre hilos del mismo proceso es mucho más rápido que entre procesos, ya que no requiere el costoso cambio del mapa de memoria virtual (TLB flush).</li>
                </ul>
            </section>

            <section class="p-6 bg-red-50 rounded-xl shadow-lg border border-red-200">
                <h2 class="text-2xl font-bold mb-4 text-red-700 border-l-4 border-red-500 pl-3">6. Sincronización y Peligros de la Memoria Compartida</h2>
                <p class="text-base sm:text-lg leading-relaxed mb-4 text-gray-700">La dificultad del multihilo radica en gestionar el acceso concurrente a los datos compartidos de forma segura.</p>
                
                <h3 class="text-xl font-semibold text-red-600 mb-3">Desafíos Principales</h3>
                <ul class="list-disc list-inside text-base sm:text-lg leading-relaxed space-y-3 marker:text-red-600">
                    <li class="pl-4"><strong class="font-bold">Condiciones de Carrera:</strong> Ocurren cuando dos o más hilos acceden y modifican datos compartidos sin un control de acceso adecuado, haciendo que el resultado sea indeterminado. La solución es garantizar la <strong class="font-bold">Exclusión Mutua</strong> en las <strong class="font-bold">Secciones Críticas</strong> del código.</li>
                    <li class="pl-4"><strong class="font-bold">Interbloqueos (Deadlocks):</strong> Es la falla más grave. Ocurre cuando se cumplen las <strong>cuatro condiciones de Coffman</strong> simultáneamente: Exclusión Mutua, Retención y Espera, No Preemption (No se puede forzar la liberación) y Espera Circular.
                        <div class="mt-2 p-3 bg-red-100 rounded-lg border border-red-300">
                            <strong class="text-red-700">📌 La Cena de los Filósofos (Ejemplo Clásico de Espera Circular):</strong> Este problema ilustra el interbloqueo con 5 filósofos (hilos) y 5 tenedores (recursos). Si cada filósofo toma un tenedor de un lado y luego espera por el otro (una secuencia de toma ineficiente), se establece una <strong>cadena de espera circular</strong> donde nadie puede obtener los dos recursos que necesita, y por lo tanto, nadie come ni libera recursos. La solución a menudo implica un <strong>orden jerárquico</strong> en la toma de recursos (p. ej., el último filósofo debe tomar el tenedor en orden inverso).
                        </div>
                    </li>
                    <li class="pl-4"><strong class="font-bold">Inanición (Starvation):</strong> Un hilo nunca obtiene los recursos que necesita o nunca se le asigna tiempo de CPU debido a una planificación injusta, aunque los recursos estén disponibles.</li>
                </ul>
            </section>
        </div>

        <hr class="my-12 border-blue-200">

        <section class="mb-14">
            <h2 class="text-2xl sm:text-3xl font-bold mb-6">7. Aplicaciones Reales: ¿Dónde se Usa el Multihilo?</h2>
            <p class="text-base sm:text-lg leading-relaxed mb-6 text-gray-700">La programación multihilo es la base para lograr la simultaneidad y capacidad de respuesta en casi todos los sistemas operativos modernos y aplicaciones de alto rendimiento.</p>
            
            <div class="grid grid-cols-1 sm:grid-cols-2 xl:grid-cols-4 gap-6">
                
                <div class="p-5 bg-indigo-50 rounded-lg shadow-md hover:shadow-xl transition duration-300">
                    <h3 class="font-extrabold text-indigo-700 text-xl mb-1">🎮 Videojuegos</h3>
                    <p class="text-sm text-gray-600">Un hilo maneja la IA, otro la física, otro el sonido, y múltiples hilos en la GPU se dedican al renderizado gráfico.</p>
                </div>
                
                <div class="p-5 bg-indigo-50 rounded-lg shadow-md hover:shadow-xl transition duration-300">
                    <h3 class="font-extrabold text-indigo-700 text-xl mb-1">🌐 Servidores Web</h3>
                    <p class="text-sm text-gray-600">Modelo de hilo por solicitud: un hilo gestiona cada conexión entrante, permitiendo el servicio a miles de clientes concurrentes (e.g., Apache, Nginx).</p>
                </div>
                
                <div class="p-5 bg-indigo-50 rounded-lg shadow-md hover:shadow-xl transition duration-300">
                    <h3 class="font-extrabold text-indigo-700 text-xl mb-1">💻 Sistemas de Base de Datos</h3>
                    <p class="text-sm text-gray-600">El procesamiento de consultas complejas (queries) se divide en tareas paralelas (p. ej., ordenar y filtrar datos) para reducir el tiempo de respuesta.</p>
                </div>
                
                <div class="p-5 bg-indigo-50 rounded-lg shadow-md hover:shadow-xl transition duration-300">
                    <h3 class="font-extrabold text-indigo-700 text-xl mb-1">📱 Procesamiento Multimedia</h3>
                    <p class="text-sm text-gray-600">La codificación y decodificación de video (H.264, VP9) es inherentemente paralela, asignando bloques de imagen a diferentes núcleos para un procesamiento rápido.</p>
                </div>
            </div>
        </section>

        <hr class="my-12 border-blue-200">

        <section class="p-8 bg-blue-700 text-white rounded-2xl shadow-inner">
            <h2 class="text-3xl font-extrabold mb-4 border-b-2 border-blue-400 pb-2">8. Conclusión: El Paradigma del Paralelismo</h2>
            <p class="text-lg leading-relaxed mb-4 font-light">El procesamiento multinúcleo y la programación multihilo representan el principal motor del crecimiento computacional actual. La gestión eficiente de la concurrencia es el desafío que separa una aplicación funcional de una aplicación de alto rendimiento.</p>
            <p class="text-lg leading-relaxed font-semibold">El diseño de sistemas modernos exige un conocimiento profundo de la arquitectura de hilos para desarrollar software que no solo funcione, sino que maximice el potencial del hardware y evite fallos catastróficos como el interbloqueo.</p>
        </section>
        
    </main>

    <footer class="mt-10 text-gray-600 text-sm text-center no-print">
        <p>© Diseñado por Faginoli Oyarzun y Calviño.</p>
    </footer>

</body>
</html>
